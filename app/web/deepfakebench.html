<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Version: 2.1.0 - Real-time progress updates -->
    <title>DeepfakeBench Video Analysis</title>
    <link rel="stylesheet" href="/web/css/app.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        /* Navigation Bar */
        .navbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-radius: 12px 12px 0 0;
        }
        
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .nav-brand {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
            text-decoration: none;
        }
        
        .nav-links {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .nav-link {
            padding: 8px 16px;
            border-radius: 8px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .nav-link:hover {
            background: #f0f0f0;
            color: #667eea;
        }
        
        .nav-link.active {
            background: #667eea;
            color: white;
        }
        
        .main-content {
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: #f9f9ff;
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: #f0f0ff;
        }
        
        #fileInput {
            display: none;
        }
        
        .model-selector {
            margin: 20px 0;
            padding: 20px;
            background: #f9f9ff;
            border-radius: 8px;
        }
        
        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .model-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .model-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }
        
        .model-card.selected {
            border-color: #667eea;
            background: #f0f0ff;
        }
        
        .model-card.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .model-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }
        
        .model-info {
            font-size: 12px;
            color: #666;
        }
        
        .parameters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .param-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 500;
            margin-bottom: 5px;
            color: #333;
        }
        
        input[type="number"] {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress-container {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        .progress-container.show {
            display: block;
        }
        
        /* Custom progress bar to match TruFor style */
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .progress-stage {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }
        
        .progress-percent {
            font-size: 14px;
            color: #6B7280;
        }
        
        .progress-bar-custom {
            width: 100%;
            height: 12px;
            background-color: #E5E7EB;
            border-radius: 9999px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            border-radius: 9999px;
        }
        
        .progress-message {
            font-size: 12px;
            color: #9CA3AF;
            margin-top: 4px;
        }
        
        .result {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            display: none;
        }
        
        .result.show {
            display: block;
        }
        
        .verdict {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .verdict.real {
            background: #d4edda;
            color: #155724;
        }
        
        .verdict.fake {
            background: #f8d7da;
            color: #721c24;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric {
            background: #f9f9ff;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .segments {
            margin-top: 20px;
        }
        
        .segment {
            background: #fff5f5;
            border-left: 4px solid #e74c3c;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        /* Timeline Chart Styles */
        .timeline-section {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .timeline-chart {
            position: relative;
            height: 100px;
            background: linear-gradient(to bottom, #f5f5f5 0%, #ffffff 100%);
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px 0;
            overflow: visible;
        }
        
        .timeline-segment {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(244, 67, 54, 0.6);
            border: 1px solid rgb(198, 40, 40);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 11px;
            font-weight: bold;
        }
        
        .timeline-segment:hover {
            background: rgba(244, 67, 54, 0.9);
            transform: scaleY(1.1);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .timeline-time-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }
        
        .threshold-control {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .threshold-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .threshold-value {
            background: #4CAF50;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .timeline-legend {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-box {
            width: 24px;
            height: 16px;
            border-radius: 3px;
        }
        
        /* Model Detail Info Icon */
        .model-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .model-info-icon {
            background: #667eea;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
        }
        
        .model-info-icon:hover {
            background: #764ba2;
            transform: scale(1.1);
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .modal-close {
            background: #f0f0f0;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            padding: 0;
        }
        
        .modal-close:hover {
            background: #e0e0e0;
            transform: rotate(90deg);
        }
        
        .modal-body {
            color: #333;
        }
        
        .modal-section {
            margin-bottom: 20px;
        }
        
        .modal-section-title {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .modal-section-content {
            font-size: 14px;
            line-height: 1.6;
            color: #666;
        }
        
        .modal-section-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .modal-section-content li {
            margin: 5px 0;
        }
        
        .pros-icon {
            color: #27ae60;
        }
        
        .cons-icon {
            color: #e74c3c;
        }
        
        .info-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            margin-right: 8px;
        }
        
        .badge-speed {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .badge-accuracy {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .badge-complexity {
            background: #fff3e0;
            color: #e65100;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="/web/index_main.html" class="nav-brand">🎭 Deepfake Detector</a>
            <div class="nav-links">
                <a href="/web/index_main.html" class="nav-link">
                    <span>🏠</span>
                    <span>Home</span>
                </a>
                <a href="/web/index.html" class="nav-link">
                    <span>🎯</span>
                    <span>TruFor Detection</span>
                </a>
                <a href="/web/deepfakebench.html" class="nav-link active">
                    <span>🔬</span>
                    <span>DeepfakeBench</span>
                </a>
            </div>
        </div>
    </nav>
    
    <div class="main-content">
        <div class="container">
            <h1>🎬 DeepfakeBench Video Analysis</h1>
            <p class="subtitle">Detect deepfake videos using 13 advanced deep learning models</p>
        
        <!-- Upload Area -->
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 48px; margin-bottom: 10px;">📁</div>
            <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">
                Click or drag & drop video file here
            </div>
            <div style="color: #666;">
                Supports MP4, MOV, AVI, WebM formats, max 500MB
            </div>
            <input type="file" id="fileInput" accept="video/*">
        </div>
        
        <div id="fileName" style="text-align: center; color: #667eea; font-weight: bold; margin: 10px 0;"></div>
        
        <!-- Model Selector -->
        <div class="model-selector">
            <h3>Select Detection Model</h3>
            <div class="model-grid" id="modelGrid">
                <div style="grid-column: 1/-1; text-align: center; color: #666;">
                    Loading models...
                </div>
            </div>
        </div>
        
        <!-- Hidden Parameters (using defaults) -->
        <input type="hidden" id="fps" value="10">
        <input type="hidden" id="threshold" value="0.5">
        
        <!-- Analyze Button -->
        <button id="analyzeBtn" disabled>Select file and model to start analysis</button>
        
        <!-- Progress -->
        <div class="progress-container" id="progress">
            <div class="progress-header">
                <span class="progress-stage" id="progressStage">Preparing...</span>
                <span class="progress-percent" id="progressPercent">0%</span>
            </div>
            <div class="progress-bar-custom">
                <div class="progress-bar-fill" id="progressBar" style="width: 0%"></div>
            </div>
            <p class="progress-message" id="progressMessage"></p>
        </div>
        
        <!-- Results -->
        <div class="result" id="result">
            <h2>Analysis Results</h2>
            <div class="verdict" id="verdict"></div>
            
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="overallScore">--</div>
                    <div class="metric-label">Overall Score</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="averageScore">--</div>
                    <div class="metric-label">Average Score</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="totalFrames">--</div>
                    <div class="metric-label">Frames Analyzed</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="segmentCount">--</div>
                    <div class="metric-label">Suspicious Segments</div>
                </div>
            </div>
            
            <!-- Timeline Section -->
            <div class="timeline-section" id="timelineSection" style="display: none;">
                <h3 style="margin-bottom: 15px;">⏱️ Detection Timeline</h3>
                
                <!-- Legend -->
                <div class="timeline-legend">
                    <div class="legend-item">
                        <div class="legend-box" style="background: rgba(244, 67, 54, 0.6); border: 1px solid rgb(198, 40, 40);"></div>
                        <span>Suspicious Segments</span>
                    </div>
                </div>
                
                <!-- Threshold Control -->
                <div class="threshold-control">
                    <div class="threshold-label">
                        <span>Adjust Detection Threshold</span>
                        <span class="threshold-value" id="currentThreshold">50%</span>
                    </div>
                    <div class="slider-container">
                        <span style="font-size: 12px; color: #666;">0%</span>
                        <input type="range" id="thresholdSlider" min="0" max="100" value="50" 
                               oninput="updateThreshold(this.value)">
                        <span style="font-size: 12px; color: #666;">100%</span>
                    </div>
                    <div style="margin-top: 8px; font-size: 12px; color: #666; text-align: center;">
                        Higher = stricter detection (fewer segments)
                    </div>
                </div>
                
                <!-- Timeline Chart -->
                <div id="timelineChart" class="timeline-chart">
                    <!-- Segments will be rendered here -->
                </div>
                <div class="timeline-time-labels">
                    <span>0:00</span>
                    <span id="timelineEnd">--:--</span>
                </div>
            </div>
            
            <div id="segmentsContainer"></div>
        </div>
        
        <div class="error" id="error" style="display: none;"></div>
    </div>

    <script>
        let selectedFile = null;
        let selectedModel = 'xception';
        let availableModels = [];
        let currentJobId = null;
        let currentResult = null;  // Store full analysis result
        let videoDuration = 0;     // Video duration in seconds
        let originalSegments = [];  // Store original segments with keyframes
        let originalThreshold = 0.5;  // Store original threshold from server
        
        // Model detailed information
        const modelDetails = {
            'xception': {
                description: 'Xception is a deep learning architecture based on depthwise separable convolutions. It excels at detecting face manipulation artifacts.',
                pros: [
                    'High detection accuracy across various deepfake types',
                    'Robust to compression and quality degradation',
                    'Well-established architecture with proven performance',
                    'Balanced speed and accuracy'
                ],
                cons: [
                    'Medium processing speed compared to lightweight models',
                    'May struggle with very high-quality deepfakes',
                    'Requires significant GPU memory'
                ],
                useCases: 'General-purpose deepfake detection, suitable for most scenarios',
                complexity: 'Medium'
            },
            'meso4': {
                description: 'MesoNet-4 is a lightweight CNN specifically designed for deepfake detection, focusing on mesoscopic features.',
                pros: [
                    'Very fast inference speed',
                    'Low computational requirements',
                    'Good for real-time applications',
                    'Compact model size'
                ],
                cons: [
                    'Medium accuracy compared to deeper models',
                    'May miss subtle manipulations',
                    'Less robust to variations'
                ],
                useCases: 'Real-time detection, resource-constrained environments',
                complexity: 'Low'
            },
            'meso4Inception': {
                description: 'Enhanced version of MesoNet-4 with Inception modules for multi-scale feature extraction.',
                pros: [
                    'Fast processing speed',
                    'Better multi-scale feature detection than MesoNet-4',
                    'Good balance of speed and accuracy',
                    'Relatively lightweight'
                ],
                cons: [
                    'Still medium accuracy level',
                    'Not as robust as heavier models',
                    'May require fine-tuning for specific datasets'
                ],
                useCases: 'Scenarios requiring fast processing with moderate accuracy',
                complexity: 'Low-Medium'
            },
            'f3net': {
                description: 'F3-Net focuses on frequency domain analysis to detect deepfake artifacts invisible in spatial domain.',
                pros: [
                    'Excellent at detecting frequency-domain artifacts',
                    'Robust to spatial manipulations',
                    'High accuracy on generated faces',
                    'Complementary to spatial-domain methods'
                ],
                cons: [
                    'Medium processing speed',
                    'May require specific preprocessing',
                    'Less effective on heavily compressed videos'
                ],
                useCases: 'Detecting high-quality deepfakes, frequency analysis scenarios',
                complexity: 'Medium'
            },
            'efficientnetb4': {
                description: 'EfficientNet-B4 uses compound scaling to balance network depth, width, and resolution for optimal performance.',
                pros: [
                    'State-of-the-art accuracy',
                    'Efficient parameter utilization',
                    'Strong generalization capability',
                    'Excellent feature extraction'
                ],
                cons: [
                    'Slower inference than lightweight models',
                    'Higher memory requirements',
                    'May be overkill for simple cases'
                ],
                useCases: 'High-accuracy requirements, final verification stage',
                complexity: 'High'
            },
            'capsule_net': {
                description: 'Capsule Network uses capsule structures to better model spatial hierarchies and part-whole relationships.',
                pros: [
                    'Very fast inference',
                    'Novel architecture for deepfake detection',
                    'Good at capturing facial structure inconsistencies',
                    'Low resource consumption'
                ],
                cons: [
                    'Medium accuracy',
                    'May struggle with subtle manipulations',
                    'Less proven track record'
                ],
                useCases: 'Quick preliminary screening, mobile applications',
                complexity: 'Medium'
            },
            'srm': {
                description: 'Spatial Rich Model focuses on steganalysis features to detect manipulation traces at pixel level.',
                pros: [
                    'Excellent at detecting low-level artifacts',
                    'High sensitivity to pixel-level manipulations',
                    'Robust detection capability',
                    'Good for forensic analysis'
                ],
                cons: [
                    'Medium processing speed',
                    'May produce false positives on compressed images',
                    'Requires careful threshold tuning'
                ],
                useCases: 'Forensic investigation, detailed pixel-level analysis',
                complexity: 'Medium-High'
            },
            'recce': {
                description: 'RECCE (Recurrent Convolutional Network) leverages temporal information for video-based deepfake detection.',
                pros: [
                    'Good temporal consistency detection',
                    'High accuracy on video sequences',
                    'Captures inter-frame relationships',
                    'Effective on deepfake videos'
                ],
                cons: [
                    'Medium processing speed',
                    'Requires sequential frame processing',
                    'Higher memory usage'
                ],
                useCases: 'Video-focused detection, temporal analysis',
                complexity: 'Medium-High'
            },
            'spsl': {
                description: 'SPSL (Spatial-Phase Shallow Learning) combines spatial and frequency domain features for robust detection.',
                pros: [
                    'Hybrid spatial-frequency analysis',
                    'High detection accuracy',
                    'Robust to various manipulation types',
                    'Good generalization'
                ],
                cons: [
                    'Medium processing speed',
                    'Moderate computational requirements',
                    'Complex feature engineering'
                ],
                useCases: 'Comprehensive detection requiring multi-domain analysis',
                complexity: 'Medium'
            },
            'ucf': {
                description: 'UCF model specializes in detecting facial reenactment and expression manipulation.',
                pros: [
                    'Excellent for facial expression manipulation',
                    'High accuracy on reenactment attacks',
                    'Good at detecting subtle facial changes',
                    'Specialized for facial manipulation'
                ],
                cons: [
                    'Medium processing speed',
                    'Focused on facial region only',
                    'May miss non-facial manipulations'
                ],
                useCases: 'Face swap detection, expression manipulation identification',
                complexity: 'Medium'
            },
            'cnn_aug': {
                description: 'CNN with augmentation techniques to improve robustness and generalization across different deepfake types.',
                pros: [
                    'Good generalization due to augmentation',
                    'High robustness to variations',
                    'Balanced performance',
                    'Moderate speed'
                ],
                cons: [
                    'Medium accuracy ceiling',
                    'Requires more training data',
                    'Medium computational cost'
                ],
                useCases: 'General detection with emphasis on robustness',
                complexity: 'Medium'
            },
            'core': {
                description: 'CORE focuses on identifying core manipulation patterns through attention mechanisms.',
                pros: [
                    'Attention-based feature selection',
                    'High accuracy on key manipulation areas',
                    'Good interpretability',
                    'Effective artifact localization'
                ],
                cons: [
                    'Medium processing speed',
                    'Requires more computational resources',
                    'Complex attention mechanism'
                ],
                useCases: 'Detailed analysis requiring manipulation localization',
                complexity: 'Medium-High'
            }
        };
        
        // Load available models
        async function loadModels() {
            try {
                const response = await fetch('/api/deepfakebench/models');
                const data = await response.json();
                availableModels = data.models;
                renderModels();
            } catch (error) {
                console.error('Failed to load models:', error);
                document.getElementById('modelGrid').innerHTML = 
                    '<div style="grid-column: 1/-1; text-align: center; color: #e74c3c;">Failed to load models</div>';
            }
        }
        
        function renderModels() {
            const grid = document.getElementById('modelGrid');
            grid.innerHTML = '';
            
            availableModels.forEach(model => {
                const card = document.createElement('div');
                card.className = `model-card ${model.available ? '' : 'unavailable'} ${model.key === selectedModel ? 'selected' : ''}`;
                card.innerHTML = `
                    <div class="model-card-header">
                        <div class="model-name">${model.name}</div>
                        <div class="model-info-icon" onclick="event.stopPropagation(); showModelDetail('${model.key}')" title="View detailed information">ℹ</div>
                    </div>
                    <div class="model-info">
                        Speed: ${model.speed}<br>
                        Accuracy: ${model.accuracy}<br>
                        ${model.available ? '✅ Available' : '❌ Unavailable'}
                    </div>
                `;
                
                if (model.available) {
                    card.onclick = () => selectModel(model.key);
                }
                
                grid.appendChild(card);
            });
        }
        
        function selectModel(modelKey) {
            selectedModel = modelKey;
            renderModels();
            updateAnalyzeButton();
        }
        
        // Show model detail modal
        function showModelDetail(modelKey) {
            const detail = modelDetails[modelKey];
            if (!detail) {
                console.error('No details found for model:', modelKey);
                return;
            }
            
            const modelName = availableModels.find(m => m.key === modelKey)?.name || modelKey;
            
            document.getElementById('modalModelName').textContent = modelName;
            document.getElementById('modalBody').innerHTML = `
                <div class="modal-section">
                    <div style="margin-bottom: 15px;">
                        <span class="info-badge badge-speed">Speed: ${availableModels.find(m => m.key === modelKey)?.speed || 'N/A'}</span>
                        <span class="info-badge badge-accuracy">Accuracy: ${availableModels.find(m => m.key === modelKey)?.accuracy || 'N/A'}</span>
                        <span class="info-badge badge-complexity">Complexity: ${detail.complexity}</span>
                    </div>
                    <p style="font-size: 14px; line-height: 1.6; color: #666; margin-bottom: 20px;">${detail.description}</p>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title"><span class="pros-icon">✓</span> Advantages</div>
                    <div class="modal-section-content">
                        <ul>
                            ${detail.pros.map(pro => `<li>${pro}</li>`).join('')}
                        </ul>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title"><span class="cons-icon">✗</span> Limitations</div>
                    <div class="modal-section-content">
                        <ul>
                            ${detail.cons.map(con => `<li>${con}</li>`).join('')}
                        </ul>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">💡 Best Use Cases</div>
                    <div class="modal-section-content">
                        ${detail.useCases}
                    </div>
                </div>
            `;
            
            const modal = document.getElementById('modelDetailModal');
            modal.classList.add('show');
            
            // Close modal when clicking outside
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closeModelDetail();
                }
            };
        }
        
        // Close model detail modal
        function closeModelDetail() {
            const modal = document.getElementById('modelDetailModal');
            modal.classList.remove('show');
            modal.onclick = null;
        }
        
        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModelDetail();
            }
        });
        
        // Upload area handlers
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.onclick = () => fileInput.click();
        
        uploadArea.ondragover = (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        };
        
        uploadArea.ondragleave = () => {
            uploadArea.classList.remove('dragover');
        };
        
        uploadArea.ondrop = (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFileSelect(e.dataTransfer.files[0]);
            }
        };
        
        fileInput.onchange = (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        };
        
        function handleFileSelect(file) {
            selectedFile = file;
            document.getElementById('fileName').textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
            updateAnalyzeButton();
        }
        
        function updateAnalyzeButton() {
            const btn = document.getElementById('analyzeBtn');
            if (selectedFile && selectedModel) {
                btn.disabled = false;
                btn.textContent = `Analyze with ${availableModels.find(m => m.key === selectedModel)?.name}`;
            } else {
                btn.disabled = true;
                btn.textContent = 'Select file and model to start analysis';
            }
        }
        
        // Analyze
        document.getElementById('analyzeBtn').onclick = async () => {
            if (!selectedFile || !selectedModel) return;
            
            const fps = parseFloat(document.getElementById('fps').value);
            const threshold = parseFloat(document.getElementById('threshold').value);
            
            // Show progress
            document.getElementById('progress').classList.add('show');
            document.getElementById('result').classList.remove('show');
            document.getElementById('error').style.display = 'none';
            document.getElementById('analyzeBtn').disabled = true;
            
            try {
                // Upload and analyze
                const formData = new FormData();
                formData.append('file', selectedFile);
                formData.append('model', selectedModel);
                formData.append('fps', fps);
                formData.append('threshold', threshold);
                
                updateProgress(10, 'Uploading video...', 'Sending file to server');
                
                const response = await fetch('/api/deepfakebench/analyze', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Upload failed');
                }
                
                const { job_id } = await response.json();
                currentJobId = job_id;  // Store for keyframe loading
                
                // Poll for results
                pollJobStatus(job_id);
                
            } catch (error) {
                console.error('Analysis failed:', error);
                document.getElementById('error').textContent = `Analysis failed: ${error.message}`;
                document.getElementById('error').style.display = 'block';
                document.getElementById('progress').classList.remove('show');
                document.getElementById('analyzeBtn').disabled = false;
            }
        };
        
        async function pollJobStatus(jobId) {
            console.log(`🔄 Starting polling for job ${jobId}`);
            let pollCount = 0;
            
            // Polling function
            const doPoll = async () => {
                pollCount++;
                console.log(`🔄 Poll #${pollCount} for job ${jobId}`);
                try {
                    const response = await fetch(`/api/deepfakebench/jobs/${jobId}`);
                    const job = await response.json();
                    
                    console.log(`📊 Progress: ${job.progress}% - ${job.stage} - ${job.message}`);
                    updateProgress(job.progress || 0, job.stage || 'Processing...', job.message || '');
                    
                    if (job.status === 'completed') {
                        console.log(`✅ Job completed after ${pollCount} polls`);
                        if (interval) clearInterval(interval);
                        displayResults(job.result);
                        document.getElementById('progress').classList.remove('show');
                        document.getElementById('analyzeBtn').disabled = false;
                        return true; // Done
                    } else if (job.status === 'error') {
                        console.log(`❌ Job failed after ${pollCount} polls`);
                        if (interval) clearInterval(interval);
                        document.getElementById('error').textContent = `Analysis failed: ${job.message}`;
                        document.getElementById('error').style.display = 'block';
                        document.getElementById('progress').classList.remove('show');
                        document.getElementById('analyzeBtn').disabled = false;
                        return true; // Done
                    }
                    return false; // Continue polling
                } catch (error) {
                    console.error('Failed to poll status:', error);
                    return false;
                }
            };
            
            // Poll immediately first, then set interval
            const done = await doPoll();
            if (done) return; // Already completed
            
            // Continue polling every 500ms for smooth updates
            const interval = setInterval(async () => {
                const done = await doPoll();
                if (done && interval) clearInterval(interval);
            }, 500);
        }
        
        function updateProgress(percent, stage, message = '') {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressStage').textContent = stage;
            document.getElementById('progressMessage').textContent = message;
        }
        
        function displayResults(result) {
            // Store result for threshold updates
            currentResult = result;
            // Store original segments with keyframe information
            originalSegments = result.suspicious_segments.map(seg => ({...seg}));
            originalThreshold = result.threshold;
            console.log('📊 === ANALYSIS RESULTS ===');
            console.log('Original threshold:', originalThreshold);
            console.log('Original segments:', originalSegments);
            originalSegments.forEach((seg, i) => {
                console.log(`  Segment ${i+1}: ${seg.start.toFixed(2)}-${seg.end.toFixed(2)}s, peak at ${seg.peak_time?.toFixed(2)}s, keyframe: ${seg.keyframe_path || 'NONE'}`);
            });
            
            // Calculate video duration from frame_scores
            if (result.frame_scores && result.frame_scores.length > 0) {
                const lastFrame = result.frame_scores[result.frame_scores.length - 1];
                videoDuration = lastFrame.timestamp;
            } else if (result.suspicious_segments && result.suspicious_segments.length > 0) {
                videoDuration = Math.max(...result.suspicious_segments.map(s => s.end));
            }
            
            document.getElementById('result').classList.add('show');
            
            // Verdict
            const verdict = document.getElementById('verdict');
            verdict.textContent = result.verdict === 'FAKE' ? '⚠️ SUSPICIOUS' : '✅ AUTHENTIC';
            verdict.className = `verdict ${result.verdict === 'FAKE' ? 'fake' : 'real'}`;
            
            // Metrics
            document.getElementById('overallScore').textContent = (result.overall_score * 100).toFixed(1) + '%';
            document.getElementById('averageScore').textContent = (result.average_score * 100).toFixed(1) + '%';
            document.getElementById('totalFrames').textContent = result.total_frames;
            document.getElementById('segmentCount').textContent = result.suspicious_segments.length;
            
            // Show and render timeline
            document.getElementById('timelineSection').style.display = 'block';
            renderTimeline(result.suspicious_segments);
            
            // Set initial threshold
            const initialThreshold = (result.threshold * 100).toFixed(0);
            document.getElementById('thresholdSlider').value = initialThreshold;
            document.getElementById('currentThreshold').textContent = initialThreshold + '%';
            
            // Render segments list (show keyframes since this is original threshold)
            renderSegmentsList(result.suspicious_segments, true);
        }
        
        function renderTimeline(segments) {
            const timeline = document.getElementById('timelineChart');
            timeline.innerHTML = '';
            
            // Display video duration
            const mins = Math.floor(videoDuration / 60);
            const secs = Math.floor(videoDuration % 60);
            document.getElementById('timelineEnd').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            // Render each segment on timeline
            segments.forEach((seg, i) => {
                const segDiv = document.createElement('div');
                segDiv.className = 'timeline-segment';
                
                const leftPercent = (seg.start / videoDuration) * 100;
                const widthPercent = ((seg.end - seg.start) / videoDuration) * 100;
                
                segDiv.style.left = leftPercent + '%';
                segDiv.style.width = widthPercent + '%';
                segDiv.title = `Segment ${i + 1}: ${seg.start.toFixed(2)}s - ${seg.end.toFixed(2)}s`;
                segDiv.textContent = `#${i + 1}`;
                
                // Click to scroll to segment details
                segDiv.onclick = () => {
                    const segmentElement = document.querySelector(`[data-segment-id="${i}"]`);
                    if (segmentElement) {
                        segmentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        segmentElement.style.animation = 'pulse 0.5s';
                        setTimeout(() => segmentElement.style.animation = '', 500);
                    }
                };
                
                timeline.appendChild(segDiv);
            });
        }
        
        function renderSegmentsList(segments, showKeyframes = true) {
            const segmentsContainer = document.getElementById('segmentsContainer');
            
            if (segments.length > 0) {
                segmentsContainer.innerHTML = `<div class="segments"><h3>Suspicious Time Segments (Click on timeline to jump)</h3></div>`;
                const segmentsDiv = segmentsContainer.querySelector('.segments');
                
                segments.forEach((seg, i) => {
                    const div = document.createElement('div');
                    div.className = 'segment';
                    div.setAttribute('data-segment-id', i);
                    div.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div>
                                <strong>Segment ${i + 1}:</strong> 
                                ${formatTime(seg.start)} - ${formatTime(seg.end)}
                                <span style="color: #666;">(${seg.duration.toFixed(2)}s)</span>
                            </div>
                            ${seg.peak_score ? `
                                <div style="background: #e74c3c; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                                    Peak: ${(seg.peak_score * 100).toFixed(1)}%
                                </div>
                            ` : ''}
                        </div>
                        ${showKeyframes && seg.keyframe_path ? `
                            <div style="margin-top: 12px;">
                                <img src="/video/jobs/${currentJobId}/${seg.keyframe_path}" 
                                     alt="Keyframe ${i + 1}"
                                     style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"
                                     onerror="this.style.display='none'">
                                <div style="font-size: 12px; color: #666; margin-top: 6px;">
                                    📍 Peak detected at ${formatTime(seg.peak_time)}
                                </div>
                            </div>
                        ` : ''}
                    `;
                    segmentsDiv.appendChild(div);
                });
            } else {
                segmentsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px; background: #f9f9f9; border-radius: 8px;">✅ No suspicious segments detected with current threshold</div>';
            }
        }
        
        async function updateThreshold(value) {
            const threshold = parseFloat(value) / 100;
            document.getElementById('currentThreshold').textContent = value + '%';
            
            if (!currentResult || !currentResult.frame_scores) {
                return;
            }
            
            console.log(`\n🎚️ === THRESHOLD CHANGED TO ${(threshold*100).toFixed(0)}% ===`);
            
            // DEBUG: Show score distribution
            const probs = currentResult.frame_scores.map(f => f.probability);
            const aboveThreshold = probs.filter(p => p >= threshold).length;
            const belowThreshold = probs.filter(p => p < threshold).length;
            console.log(`📊 Score Distribution:`);
            console.log(`  - Frames >= ${(threshold*100).toFixed(0)}%: ${aboveThreshold} frames`);
            console.log(`  - Frames < ${(threshold*100).toFixed(0)}%: ${belowThreshold} frames`);
            console.log(`  - Min score: ${(Math.min(...probs)*100).toFixed(2)}%`);
            console.log(`  - Max score: ${(Math.max(...probs)*100).toFixed(2)}%`);
            console.log(`  - Avg score: ${(probs.reduce((a,b)=>a+b,0)/probs.length*100).toFixed(2)}%`);
            
            // Recalculate segments based on new threshold
            const newSegments = findSuspiciousSegments(currentResult.frame_scores, threshold, currentResult.fps);
            
            console.log(`\n✅ Found ${newSegments.length} segments (threshold=${(threshold*100).toFixed(0)}%):`);
            newSegments.forEach((seg, i) => {
                console.log(`  Segment ${i+1}: ${seg.start.toFixed(2)}-${seg.end.toFixed(2)}s (${seg.duration.toFixed(2)}s), peak=${(seg.peak_score*100).toFixed(2)}% at ${seg.peak_time.toFixed(2)}s`);
            });
            
            // Match keyframes for new segments with UNIQUE assignment
            console.log('\n🔗 Attempting to match keyframes (each keyframe used once)...');
            await matchKeyframesUnique(newSegments);
            
            // Update displays
            document.getElementById('segmentCount').textContent = newSegments.length;
            renderTimeline(newSegments);
            renderSegmentsList(newSegments, true);
        }
        
        function findSuspiciousSegments(frameScores, threshold, fps) {
            const segments = [];
            let inSegment = false;
            let segmentStartIdx = 0;
            
            // Step 1: Smooth scores (same as backend: 5-frame moving average)
            const rawProbs = frameScores.map(f => f.probability);
            const smoothed = smoothScores(rawProbs, 5);
            
            // Step 2: Find segments using smoothed scores (same as backend)
            for (let i = 0; i < smoothed.length; i++) {
                const prob = smoothed[i];
                
                if (!inSegment && prob >= threshold) {
                    inSegment = true;
                    segmentStartIdx = i;
                } else if (inSegment && prob < threshold) {
                    inSegment = false;
                    const startTime = frameScores[segmentStartIdx].timestamp;
                    const endTime = frameScores[i - 1].timestamp;
                    const duration = endTime - startTime;
                    
                    // Only keep segments >= 1 second (same as backend)
                    if (duration >= 1.0) {
                        // Find peak in this segment
                        const segmentProbs = smoothed.slice(segmentStartIdx, i);
                        const peakIdx = segmentStartIdx + segmentProbs.indexOf(Math.max(...segmentProbs));
                        
                        segments.push({
                            start: startTime,
                            end: endTime,
                            duration: duration,
                            peak_score: smoothed[peakIdx],
                            peak_time: frameScores[peakIdx].timestamp
                        });
                    }
                }
            }
            
            // Close last segment if still open
            if (inSegment && frameScores.length > 0) {
                const startTime = frameScores[segmentStartIdx].timestamp;
                const endTime = frameScores[frameScores.length - 1].timestamp;
                const duration = endTime - startTime;
                
                if (duration >= 1.0) {
                    const segmentProbs = smoothed.slice(segmentStartIdx);
                    const peakIdx = segmentStartIdx + segmentProbs.indexOf(Math.max(...segmentProbs));
                    
                    segments.push({
                        start: startTime,
                        end: endTime,
                        duration: duration,
                        peak_score: smoothed[peakIdx],
                        peak_time: frameScores[peakIdx].timestamp
                    });
                }
            }
            
            return segments;
        }
        
        // Smooth scores using moving average (same as backend's np.convolve)
        function smoothScores(scores, windowSize) {
            if (scores.length < windowSize) {
                return scores;
            }
            
            const smoothed = [];
            for (let i = 0; i < scores.length; i++) {
                let sum = 0;
                let count = 0;
                
                // Calculate window boundaries (same as numpy's 'same' mode)
                const halfWindow = Math.floor(windowSize / 2);
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(scores.length, i + halfWindow + 1);
                
                for (let j = start; j < end; j++) {
                    sum += scores[j];
                    count++;
                }
                
                smoothed.push(sum / count);
            }
            
            return smoothed;
        }
        
        async function matchKeyframesUnique(newSegments) {
            // Build a match matrix: for each new segment, find all possible original segments
            const matches = [];
            
            newSegments.forEach((newSeg, newIdx) => {
                console.log(`\n  🔍 Segment ${newIdx+1}: ${newSeg.start.toFixed(2)}-${newSeg.end.toFixed(2)}s`);
                
                originalSegments.forEach((origSeg, origIdx) => {
                    if (!origSeg.keyframe_path || !origSeg.peak_time) return;
                    
                    console.log(`    - Original Segment ${origIdx+1}: ${origSeg.start.toFixed(2)}-${origSeg.end.toFixed(2)}s, peak at ${origSeg.peak_time.toFixed(2)}s`);
                    
                    // CRITICAL CHECK: The keyframe's peak_time MUST be within the new segment's time range
                    const isPeakWithinNewSeg = origSeg.peak_time >= newSeg.start && origSeg.peak_time <= newSeg.end;
                    
                    if (!isPeakWithinNewSeg) {
                        console.log(`      ❌ Peak ${origSeg.peak_time.toFixed(2)}s is OUTSIDE new segment [${newSeg.start.toFixed(2)}-${newSeg.end.toFixed(2)}]`);
                        return;
                    }
                    
                    console.log(`      ✅ Peak ${origSeg.peak_time.toFixed(2)}s is WITHIN new segment [${newSeg.start.toFixed(2)}-${newSeg.end.toFixed(2)}]`);
                    
                    // Calculate time overlap for scoring
                    const overlapStart = Math.max(newSeg.start, origSeg.start);
                    const overlapEnd = Math.min(newSeg.end, origSeg.end);
                    const overlapDuration = Math.max(0, overlapEnd - overlapStart);
                    const overlapRatio = overlapDuration / newSeg.duration;
                    
                    console.log(`      Overlap: ${overlapDuration.toFixed(2)}s / ${newSeg.duration.toFixed(2)}s = ${(overlapRatio * 100).toFixed(1)}%`);
                    
                    // Add to candidates
                    matches.push({
                        newIdx,
                        origIdx,
                        overlapRatio,
                        origSeg
                    });
                });
            });
            
            // Sort matches by overlap ratio (highest first)
            matches.sort((a, b) => b.overlapRatio - a.overlapRatio);
            
            // Assign keyframes greedily (best matches first)
            const usedOriginals = new Set();
            const usedNews = new Set();
            
            console.log(`\n🎯 Assigning keyframes (greedy, peak_time must be within segment):`);
            
            for (const match of matches) {
                // Skip if either segment already used
                if (usedOriginals.has(match.origIdx) || usedNews.has(match.newIdx)) {
                    continue;
                }
                
                // Assign keyframe
                const newSeg = newSegments[match.newIdx];
                newSeg.keyframe_path = match.origSeg.keyframe_path;
                newSeg.peak_time = match.origSeg.peak_time;
                newSeg.peak_score = match.origSeg.peak_score;
                
                usedOriginals.add(match.origIdx);
                usedNews.add(match.newIdx);
                
                console.log(`  ✅ Segment ${match.newIdx+1} ← Original Segment ${match.origIdx+1} (${(match.overlapRatio * 100).toFixed(1)}% overlap, peak at ${match.origSeg.peak_time.toFixed(2)}s)`);
            }
            
            // Generate keyframes for unmatched segments
            console.log(`\n🎬 Generating keyframes for unmatched segments...`);
            const unmatchedSegments = [];
            newSegments.forEach((seg, idx) => {
                if (!usedNews.has(idx)) {
                    unmatchedSegments.push({ seg, idx });
                }
            });
            
            if (unmatchedSegments.length > 0) {
                console.log(`  Found ${unmatchedSegments.length} segments without keyframes`);
                
                // Generate keyframes in parallel
                const keyframePromises = unmatchedSegments.map(async ({ seg, idx }) => {
                    try {
                        console.log(`  🔄 Generating keyframe for Segment ${idx+1} at ${seg.peak_time.toFixed(2)}s...`);
                        
                        const response = await fetch(`/api/deepfakebench/jobs/${currentJobId}/extract-keyframe?timestamp=${seg.peak_time}`, {
                            method: 'POST'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            seg.keyframe_path = data.keyframe_path;
                            console.log(`  ✅ Segment ${idx+1}: Generated keyframe at ${data.keyframe_path}`);
                        } else {
                            console.log(`  ❌ Segment ${idx+1}: Failed to generate keyframe (${response.status})`);
                        }
                    } catch (error) {
                        console.log(`  ❌ Segment ${idx+1}: Error generating keyframe:`, error);
                    }
                });
                
                // Wait for all keyframes to be generated
                await Promise.all(keyframePromises);
                console.log(`  ✅ Keyframe generation complete`);
            } else {
                console.log(`  No segments need keyframe generation`);
            }
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${mins}:${secs.padStart(5, '0')}`;
        }
        
        // Initialize
        loadModels();
    </script>
    </div> <!-- /main-content -->
    
    <!-- Model Detail Modal -->
    <div id="modelDetailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalModelName">Model Details</h2>
                <button class="modal-close" onclick="closeModelDetail()">×</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be dynamically inserted -->
            </div>
        </div>
    </div>
</body>
</html>

