<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepfake Detection System</title>
    <link href="/web/css/app-compiled.css" rel="stylesheet">
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in {
            animation: fadeIn 0.6s ease-out;
        }
        
        .stat:hover {
            transform: translateY(-2px);
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
        }
        
        .canvas-container:hover .hover-overlay {
            opacity: 1;
        }
        
        .hover-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .progress-bar {
            transition: width 0.8s ease-in-out;
        }
        
        .decision-badge {
            transition: all 0.3s ease;
        }
        
        .decision-badge:hover {
            transform: scale(1.05);
        }
        
        dialog[open] {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        dialog::backdrop {
            background: rgba(0, 0, 0, 0.5);
        }
        
        .modal-box {
            margin: 1rem;
            max-width: 32rem;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="min-h-screen bg-base-200">
    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <!-- Title -->
        <div class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold mb-2">Deepfake Detection System</h1>
            <p class="text-base-content/60">AI-powered image and video authenticity detection</p>
        </div>
        
        <!-- Upload Card -->
        <div id="uploadCard" class="card bg-base-100 shadow-xl">
            <div class="card-body">
                <!-- Upload Zone -->
                <div id="uploadZone" 
                     class="border-2 border-dashed border-base-300 rounded-lg p-8 md:p-12 text-center hover:border-primary transition-colors cursor-pointer">
                    
                    <!-- Upload Icon -->
                    <svg class="w-16 h-16 mx-auto mb-4 text-base-content opacity-30" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                              d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                    </svg>
                    
                    <p class="text-lg font-medium mb-2">Drag and drop file here</p>
                    <p class="text-sm text-base-content/60 mb-4">or</p>
                    
                    <!-- File Selection Button -->
                    <input type="file" 
                           id="fileInput" 
                           class="file-input file-input-bordered file-input-primary w-full max-w-xs" 
                           accept=".jpg,.jpeg,.png">
                    
                    <!-- File Requirements -->
                    <div class="mt-6 space-y-1">
                        <p class="text-xs text-base-content/50">Supported formats: JPG, PNG</p>
                        <p class="text-xs text-base-content/50">Max size: Images 10MB</p>
                    </div>
                    
                    <!-- Keyboard Shortcuts -->
                    <div class="mt-4 text-xs text-base-content/40">
                        <p class="font-medium mb-1">💡 Keyboard shortcuts:</p>
                        <div class="space-y-1">
                            <p>• <kbd class="kbd kbd-xs">Ctrl</kbd> + <kbd class="kbd kbd-xs">Enter</kbd> - Select file</p>
                            <p>• <kbd class="kbd kbd-xs">Ctrl</kbd> + <kbd class="kbd kbd-xs">R</kbd> - Reset</p>
                            <p>• <kbd class="kbd kbd-xs">Esc</kbd> - Close modal</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Loading State -->
        <div id="loadingState" class="hidden">
            <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                    <div class="flex flex-col items-center justify-center py-12">
                        <span class="loading loading-spinner loading-lg text-primary"></span>
                        <p class="mt-4 text-base-content/70">Analyzing...</p>
                        <div class="w-full bg-gray-200 rounded-full h-2.5 mt-4 max-w-md">
                            <div id="progressBar" class="bg-primary h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                        <p id="loadingText" class="mt-2 text-sm text-base-content/50">Initializing model...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Error Alert -->
        <div id="errorAlert" class="alert alert-error hidden">
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span id="errorText">Error message</span>
        </div>
        
        <!-- Results Display -->
        <div id="resultPanel" class="hidden mt-8 space-y-4">
            <!-- Status Alert -->
            <div id="statusAlert" class="alert shadow-lg">
                <svg id="statusIcon" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"></svg>
                <span id="statusContent">
                    <span id="statusTitle" class="font-bold"></span>
                    <span id="statusText" class="text-xs ml-2"></span>
                </span>
            </div>
            
            <!-- Statistics -->
            <div class="stats shadow w-full bg-base-100 grid grid-cols-1 md:grid-cols-3 gap-4 animate-fade-in">
                <div class="stat bg-base-100 rounded-lg p-4 hover:shadow-lg transition-all duration-300 cursor-pointer decision-badge" id="decisionStat">
                    <div class="stat-title text-sm font-medium text-base-content/70">Decision</div>
                    <div class="stat-value text-3xl font-bold" id="resultStatus"></div>
                    <div class="stat-desc text-xs text-base-content/60" id="resultDesc"></div>
                    <div class="text-xs text-primary mt-1 opacity-75 hover:opacity-100 transition-opacity duration-300 font-semibold">Click for details</div>
                </div>
                
                <div class="stat bg-base-100 rounded-lg p-4">
                    <div class="stat-title text-sm font-medium text-base-content/70">Evidence Reliability</div>
                    <div class="stat-value">
                        <div class="text-3xl font-bold" id="confidenceText"></div>
                    </div>
                    <div class="stat-desc">
                        <progress id="confidenceBar" 
                                  class="progress progress-primary w-full progress-bar" 
                                  value="0" max="100"></progress>
                        <div class="text-xs text-base-content/60 mt-1">From confidence map (black=low, white=high)</div>
                    </div>
                </div>
                
                <div class="stat bg-base-100 rounded-lg p-4" id="detectionScoreStat" style="display: none;">
                    <div class="stat-title text-sm font-medium text-base-content/70">Authenticity</div>
                    <div class="stat-value">
                        <div class="text-3xl font-bold" id="detectionScoreText"></div>
                        <div class="text-xs text-base-content/60">Higher = more authentic</div>
                    </div>
                    <div class="stat-desc">
                        <progress id="detectionScoreBar" 
                                  class="progress progress-primary w-full progress-bar" 
                                  value="0" max="100"></progress>
                    </div>
                </div>
                
                <div class="stat bg-base-100 rounded-lg p-4" id="fakeLikelihoodStat" style="display: none;">
                    <div class="stat-title text-sm font-medium text-base-content/70">Fake Likelihood</div>
                    <div class="stat-value">
                        <div class="text-3xl font-bold" id="fakeLikelihoodText"></div>
                        <div class="text-xs text-base-content/60">Higher = more likely forged</div>
                    </div>
                    <div class="stat-desc">
                        <progress id="fakeLikelihoodBar" 
                                  class="progress progress-error w-full progress-bar" 
                                  value="0" max="100"></progress>
                        <div class="text-xs text-base-content/60 mt-1">Threshold: 50%</div>
                    </div>
                </div>
            </div>
            
            <!-- TruFor Visualization Area -->
            <div id="truforVisualization" class="hidden">
                <!-- Image and Heatmap Comparison -->
                <div class="card bg-base-100 shadow-xl">
                    <div class="card-body" style="padding: 1.5rem;">
                        <h3 class="card-title text-lg mb-4">TruFor Analysis</h3>
                        
                        <!-- 2x2 Grid Layout for Four Images -->
                        <div style="display: grid !important; grid-template-columns: 1fr 1fr !important; grid-template-rows: 1fr 1fr !important; gap: 1rem !important; margin-bottom: 0.25rem !important; width: 100% !important;">
                            <!-- Original Image -->
                            <div style="display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: flex-start !important;">
                                <!-- Spacer to align with toggle button (button height + border + margin-bottom) -->
                                <div style="margin-bottom: 0.5rem !important;">
                                    <div style="display: inline-flex !important; border-radius: 0.375rem !important; overflow: hidden !important; border: 1px solid transparent !important; visibility: hidden !important;">
                                        <button class="btn btn-xs" style="padding: 0.25rem 0.5rem !important; font-size: 0.625rem !important; opacity: 0 !important; pointer-events: none !important;">Raw</button>
                                        <button class="btn btn-xs" style="padding: 0.25rem 0.5rem !important; font-size: 0.625rem !important; opacity: 0 !important; pointer-events: none !important;">Weighted</button>
                                    </div>
                                </div>
                                
                                <h4 style="font-size: 0.875rem !important; font-weight: 500 !important; margin-bottom: 0.75rem !important;">Original Image</h4>
                           <div style="position: relative !important; display: inline-block !important;">
                               <img id="originalImage" style="max-width: 300px !important; max-height: 300px !important; object-fit: contain !important; border-radius: 0.5rem !important; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important; border: 2px solid #e5e7eb !important;" alt="Original image">
                               <canvas id="predictionOverlay" style="position: absolute !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; opacity: 0.7 !important; pointer-events: none !important;"></canvas>
                           </div>
                            </div>
                            
                            <!-- Weighted Anomaly Map -->
                            <div style="display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: flex-start !important;">
                                <!-- Toggle Button -->
                                <div style="margin-bottom: 0.5rem !important;">
                                    <div class="btn-group" style="display: inline-flex !important; border-radius: 0.375rem !important; overflow: hidden !important; border: 1px solid #d1d5db !important;">
                                        <button id="btnRawAnomaly" class="btn btn-xs" style="padding: 0.25rem 0.5rem !important; font-size: 0.625rem !important; background: #3b82f6 !important; color: white !important; border: none !important; cursor: pointer !important;">Raw</button>
                                        <button id="btnWeightedAnomaly" class="btn btn-xs" style="padding: 0.25rem 0.5rem !important; font-size: 0.625rem !important; background: white !important; color: #6b7280 !important; border: none !important; cursor: pointer !important;">Weighted</button>
                                    </div>
                                </div>
                                
                                <h4 style="font-size: 0.875rem !important; font-weight: 500 !important; margin-bottom: 0.75rem !important;">Anomaly Map</h4>
                                
                                <div style="position: relative !important; display: inline-block !important;">
                                    <canvas id="predictionHeatmap" style="max-width: 300px !important; max-height: 300px !important; border-radius: 0.5rem !important; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important; border: 2px solid #e5e7eb !important; cursor: crosshair !important;" onmousemove="showHoverValues(event, 'anomaly')" onmouseleave="hideHoverValues()"></canvas>
                                    <div id="hoverTooltip" style="position: absolute !important; background: rgba(0, 0, 0, 0.8) !important; color: white !important; padding: 8px !important; border-radius: 4px !important; font-size: 12px !important; pointer-events: none !important; z-index: 1000 !important; display: none !important;"></div>
                                </div>
                                <!-- Anomaly Legend -->
                                <div style="margin-top: 0.5rem !important; text-align: center !important;">
                                    <div style="display: flex !important; align-items: center !important; justify-content: center !important; margin-bottom: 0.25rem !important;">
                                        <div style="width: 3rem !important; height: 1rem !important; border-radius: 0.25rem !important; margin-right: 0.5rem !important; background: linear-gradient(to right, #000080, #00ffff, #00ff00, #ffff00, #ff0000) !important;"></div>
                                        <span style="font-size: 0.75rem !important; font-weight: 500 !important;">Low anomaly → High anomaly</span>
                                    </div>
                                    <div style="display: flex !important; align-items: center !important; justify-content: center !important; gap: 0.5rem !important; font-size: 0.625rem !important;">
                                        <div style="display: flex !important; align-items: center !important;">
                                            <div style="width: 0.75rem !important; height: 0.75rem !important; border-radius: 50% !important; background: #000080 !important; margin-right: 0.25rem !important;"></div>
                                            <span>Normal</span>
                                        </div>
                                        <div style="display: flex !important; align-items: center !important;">
                                            <div style="width: 0.75rem !important; height: 0.75rem !important; border-radius: 50% !important; background: #00ff00 !important; margin-right: 0.25rem !important;"></div>
                                            <span>Moderate</span>
                                        </div>
                                        <div style="display: flex !important; align-items: center !important;">
                                            <div style="width: 0.75rem !important; height: 0.75rem !important; border-radius: 50% !important; background: #ff0000 !important; margin-right: 0.25rem !important;"></div>
                                            <span>High</span>
                                        </div>
                                    </div>
                                </div>
                                <div id="topKRegions" class="mt-2 text-xs text-gray-600" style="display: none;">
                                    <!-- Top-K regions will be displayed here -->
                                </div>
                            </div>
                            
                            <!-- Confidence Map -->
                            <div id="confidenceMapSection" style="display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: flex-start !important;">
                                <h4 style="font-size: 0.875rem !important; font-weight: 500 !important; margin-bottom: 0.75rem !important;">Confidence Map</h4>
                           <canvas id="confidenceMap" style="max-width: 300px !important; max-height: 300px !important; border-radius: 0.5rem !important; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important; border: 2px solid #e5e7eb !important;"></canvas>
                           <!-- Confidence Legend -->
                           <div style="margin-top: 0.5rem !important; text-align: center !important;">
                               <div style="display: flex !important; align-items: center !important; justify-content: center !important; margin-bottom: 0.25rem !important;">
                                   <div style="width: 3rem !important; height: 1rem !important; border-radius: 0.25rem !important; margin-right: 0.5rem !important; background: linear-gradient(to right, #000000, #808080, #ffffff) !important;"></div>
                                   <span style="font-size: 0.75rem !important; font-weight: 500 !important;">Unreliable → Reliable</span>
                               </div>
                               <div style="display: flex !important; align-items: center !important; justify-content: center !important; gap: 0.5rem !important; font-size: 0.625rem !important;">
                                   <div style="display: flex !important; align-items: center !important;">
                                       <div style="width: 0.75rem !important; height: 0.75rem !important; border-radius: 50% !important; background: #000000 !important; margin-right: 0.25rem !important;"></div>
                                       <span>Low</span>
                                   </div>
                                   <div style="display: flex !important; align-items: center !important;">
                                       <div style="width: 0.75rem !important; height: 0.75rem !important; border-radius: 50% !important; background: #808080 !important; margin-right: 0.25rem !important;"></div>
                                       <span>Medium</span>
                                   </div>
                                   <div style="display: flex !important; align-items: center !important;">
                                       <div style="width: 0.75rem !important; height: 0.75rem !important; border-radius: 50% !important; background: #ffffff !important; margin-right: 0.25rem !important; border: 1px solid #ccc !important;"></div>
                                       <span>High</span>
                                   </div>
                    </div>
                </div>
            </div>
            
                            <!-- Noiseprint++ -->
                            <div id="noiseprintSection" style="display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: flex-start !important;">
                                <h4 style="font-size: 0.875rem !important; font-weight: 500 !important; margin-bottom: 0.75rem !important;">Noiseprint++</h4>
                           <canvas id="noiseprintMap" style="max-width: 300px !important; max-height: 300px !important; border-radius: 0.5rem !important; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important; border: 2px solid #e5e7eb !important;"></canvas>
                           <!-- Noiseprint Legend -->
                           <div style="margin-top: 0.5rem !important; text-align: center !important;">
                               <div style="display: flex !important; align-items: center !important; justify-content: center !important; margin-bottom: 0.25rem !important;">
                                   <div style="width: 3rem !important; height: 1rem !important; border-radius: 0.25rem !important; margin-right: 0.5rem !important; background: linear-gradient(to right, #000000, #808080, #ffffff) !important;"></div>
                                   <span style="font-size: 0.75rem !important; font-weight: 500 !important;">Noise Pattern Analysis</span>
                               </div>
                               <div style="font-size: 0.625rem !important; color: #6b7280 !important;">
                                   <p>Fingerprint inconsistencies may indicate editing</p>
                               </div>
                    </div>
                </div>
                </div>
            
            
                    </div>
                </div>
            </div>
            
            <!-- Re-detect Button -->
            <div class="flex justify-center gap-4">
                <button onclick="resetUpload()" class="btn btn-primary btn-lg">
                    Analyze Another
                </button>
            </div>
            
            <!-- Decision Details Modal -->
            <div id="decisionModal" class="hidden" style="position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; background: rgba(0, 0, 0, 0.5) !important; z-index: 9999 !important; display: none !important; align-items: center !important; justify-content: center !important;" onclick="closeDecisionModal()">
                <div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 shadow-2xl" style="background: white !important; color: #1f2937 !important; min-height: 400px !important; max-height: 90vh !important; overflow-y: auto !important;" onclick="event.stopPropagation()">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">Decision Analysis</h3>
                        <button onclick="closeDecisionModal()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                    </div>
                    <div id="decisionDetails" class="space-y-4">
                        <!-- Dynamic Content -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        console.log('Script starting...');
        
        // DOM elements
        const elements = {
            uploadCard: document.getElementById('uploadCard'),
            uploadZone: document.getElementById('uploadZone'),
            fileInput: document.getElementById('fileInput'),
            loadingState: document.getElementById('loadingState'),
            errorAlert: document.getElementById('errorAlert'),
            errorText: document.getElementById('errorText'),
            resultPanel: document.getElementById('resultPanel'),
            statusAlert: document.getElementById('statusAlert'),
            statusIcon: document.getElementById('statusIcon'),
            statusTitle: document.getElementById('statusTitle'),
            statusText: document.getElementById('statusText'),
            resultStatus: document.getElementById('resultStatus'),
            resultDesc: document.getElementById('resultDesc'),
            confidenceBar: document.getElementById('confidenceBar'),
            confidenceText: document.getElementById('confidenceText'),
            detectionScoreStat: document.getElementById('detectionScoreStat'),
            detectionScoreText: document.getElementById('detectionScoreText'),
            detectionScoreBar: document.getElementById('detectionScoreBar'),
            truforVisualization: document.getElementById('truforVisualization'),
            originalImage: document.getElementById('originalImage'),
            predictionOverlay: document.getElementById('predictionOverlay'),
            predictionHeatmap: document.getElementById('predictionHeatmap'),
            confidenceMapSection: document.getElementById('confidenceMapSection'),
            confidenceMap: document.getElementById('confidenceMap'),
            noiseprintSection: document.getElementById('noiseprintSection'),
            noiseprintMap: document.getElementById('noiseprintMap'),
            fakeLikelihoodStat: document.getElementById('fakeLikelihoodStat'),
            fakeLikelihoodText: document.getElementById('fakeLikelihoodText'),
            fakeLikelihoodBar: document.getElementById('fakeLikelihoodBar'),
            decisionStat: document.getElementById('decisionStat'),
            btnRawAnomaly: document.getElementById('btnRawAnomaly'),
            btnWeightedAnomaly: document.getElementById('btnWeightedAnomaly')
        };
        
        // Check for missing elements
        console.log('Checking DOM elements...');
        for (const [name, element] of Object.entries(elements)) {
            if (!element) {
                console.error(`Missing DOM element: ${name}`);
            } else {
                console.log(`Found element: ${name}`);
            }
        }
        
        // File validation
        function validateFile(file) {
            console.log('Validating file:', file.name, file.type, file.size);
            const allowedTypes = ['image/jpeg', 'image/png'];
            const maxImageSize = 10 * 1024 * 1024; // 10MB
            
            if (!allowedTypes.includes(file.type)) {
                showError('Unsupported file type. Please upload JPG or PNG files.');
                return false;
            }
            
            if (file.size > maxImageSize) {
                showError(`File too large. Maximum size: 10MB.`);
                return false;
            }
            
            console.log('File validation passed');
            return true;
        }
        
        // Show error
        function showError(message) {
            console.error('Error:', message);
            elements.errorText.textContent = message;
            elements.errorAlert.classList.remove('hidden');
            setTimeout(() => {
                elements.errorAlert.classList.add('hidden');
            }, 5000);
        }
        
        // Handle file
        async function handleFile(file) {
            console.log('Handling file:', file.name);
            
            if (!validateFile(file)) {
                return;
            }
            
            // Hide errors and results
            elements.errorAlert.classList.add('hidden');
            elements.resultPanel.classList.add('hidden');
            
            // Hide upload card and show loading state
            elements.uploadCard.classList.add('hidden');
            elements.loadingState.classList.remove('hidden');
            
            // Update progress
            updateProgress(20, 'Validating file...');
            
            // Create FormData
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                console.log('Sending request to /detect...');
                updateProgress(40, 'Sending request to server...');
                
                const response = await fetch('/detect', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const error = await response.json();
                    console.error('API error:', error);
                    throw new Error(error.detail || 'Detection failed');
                }
                
                updateProgress(80, 'Processing results...');
                
                const result = await response.json();
                console.log('Detection result:', result);
                
                updateProgress(100, 'Complete!');
                displayResult(result);
                
            } catch (error) {
                console.error('Detection error:', error);
                showError(error.message || 'An error occurred during detection');
                resetUpload();
            }
        }
        
        // Display results
        // Decision configuration - Five-tier system
        const DECISION_CONFIG = {
            'AUTHENTIC': {
                alertClass: 'alert-success',
                title: 'AUTHENTIC',
                text: 'High confidence authentic image.',
                statText: 'AUTHENTIC',
                statColor: 'text-success',
                iconPath: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
                badgeClass: 'badge-success'
            },
            'LIKELY_AUTHENTIC': {
                alertClass: 'alert-info',
                title: 'LIKELY AUTHENTIC',
                text: 'Moderate confidence authentic image.',
                statText: 'LIKELY AUTHENTIC',
                statColor: 'text-info',
                iconPath: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                badgeClass: 'badge-info'
            },
            'INCONCLUSIVE': {
                alertClass: 'alert-warning',
                title: 'INCONCLUSIVE',
                text: 'Unable to determine authenticity with confidence.',
                statText: 'INCONCLUSIVE',
                statColor: 'text-warning',
                iconPath: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z',
                badgeClass: 'badge-warning'
            },
            'LIKELY_FORGED': {
                alertClass: 'alert-error',
                title: 'LIKELY FORGED',
                text: 'Moderate confidence forged image.',
                statText: 'LIKELY FORGED',
                statColor: 'text-error',
                iconPath: 'M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                badgeClass: 'badge-error'
            },
            'FORGED': {
                alertClass: 'alert-error',
                title: 'FORGED',
                text: 'High confidence forged image.',
                statText: 'FORGED',
                statColor: 'text-error',
                iconPath: 'M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z',
                badgeClass: 'badge-error'
            }
        };

        // Decision logic function
        function determineDecision(integrity, evidenceReliability) {
            const integrityPercent = Math.round(integrity * 100);
            const reliabilityPercent = Math.round(evidenceReliability * 100);
            
            console.log(`Decision logic: integrity=${integrityPercent}%, reliability=${reliabilityPercent}%`);
            
            if (integrityPercent >= 70 && reliabilityPercent >= 40) {
                console.log('Decision: AUTHENTIC');
                return 'AUTHENTIC';
            } else if (integrityPercent >= 55 && integrityPercent < 70) {
                console.log('Decision: LIKELY_AUTHENTIC');
                return 'LIKELY_AUTHENTIC';
            } else if (integrityPercent >= 45 && integrityPercent < 55) {
                console.log('Decision: INCONCLUSIVE');
                return 'INCONCLUSIVE';
            } else if (integrityPercent >= 30 && integrityPercent < 45 && reliabilityPercent >= 40) {
                console.log('Decision: LIKELY_FORGED');
                return 'LIKELY_FORGED';
            } else if (integrityPercent < 30 && reliabilityPercent >= 50) {
                console.log('Decision: FORGED');
                return 'FORGED';
            } else {
                console.log('Decision: INCONCLUSIVE (default)');
                return 'INCONCLUSIVE';
            }
        }

        function displayResult(data) {
            // Store current image data for hover functionality and toggle
            window.currentImageData = data;
            currentImageData = data;  // Keep for backward compatibility
            
            // Determine if this is TruFor response
            const isTruFor = data.model === 'TruFor';
            
            // Update status based on TruFor response format
            let status, config;
            if (isTruFor) {
                // Calculate evidence reliability from confidence map
                let evidenceReliability = 0.5; // Default
                if (data.confidence_map) {
                    const confData = data.confidence_map.flat();
                    const avgConfidence = confData.reduce((sum, val) => sum + val, 0) / confData.length;
                    evidenceReliability = avgConfidence;
                    console.log(`Evidence Reliability calculated: ${avgConfidence} (${Math.round(avgConfidence * 100)}%)`);
                }
                
                // Determine decision using new five-tier system
                status = determineDecision(data.integrity, evidenceReliability);
                config = DECISION_CONFIG[status];
                console.log(`Decision: integrity=${data.integrity} (${Math.round(data.integrity * 100)}%), reliability=${evidenceReliability} (${Math.round(evidenceReliability * 100)}%) -> ${status}`);
                
                // Update status alert
                elements.statusAlert.className = `alert ${config.alertClass} shadow-lg`;
                elements.statusIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${config.iconPath}" />`;
                elements.statusTitle.textContent = config.title;
                elements.statusText.textContent = config.text;
                
                // Update statistics
                elements.resultStatus.textContent = config.statText;
                elements.resultStatus.className = `stat-value text-2xl ${config.statColor}`;
                elements.resultDesc.textContent = `Model: ${data.model} | Filename: ${data.filename}`;
                
                // Update evidence reliability
                if (data.confidence_map) {
                    const confData = data.confidence_map.flat();
                    const avgConfidence = confData.reduce((sum, val) => sum + val, 0) / confData.length;
                    const reliabilityPercent = Math.round(avgConfidence * 100);
                    console.log(`Evidence Reliability display: ${avgConfidence} -> ${reliabilityPercent}%`);
                    elements.confidenceText.textContent = `${reliabilityPercent}%`;
                    elements.confidenceBar.value = reliabilityPercent;
                } else {
                    const confidence = Math.round(data.confidence * 100);
                    console.log(`Using fallback confidence: ${confidence}%`);
                    elements.confidenceBar.value = confidence;
                    elements.confidenceText.textContent = `${confidence}%`;
                }
                
                // Show detection score for TruFor
                if (data.detection_score !== undefined) {
                    elements.detectionScoreStat.style.display = 'block';
                    const detectionScore = Math.round(data.detection_score * 100);
                    elements.detectionScoreBar.value = detectionScore;
                    elements.detectionScoreText.textContent = `${detectionScore}%`;
                }
                
                // Update integrity score and fake probability
                if (data.integrity !== undefined) {
                    console.log('Updating integrity score:', data.integrity);
                    const integrityValue = Math.round(data.integrity * 100);
                    const fakeValue = Math.round((1 - data.integrity) * 100);
                    
                    
                    // Integrity bar removed - using Authenticity card instead
                }
                
                // Show TruFor visualization
                if (data.prediction_map && data.original_image_url) {
                    console.log('Setting up TruFor visualization...');
                    elements.truforVisualization.classList.remove('hidden');
                    displayTruForVisualization(data);
                    
                    // Find and display top-K regions
                    topKRegions = findTopKRegions(data.prediction_map, 3);
                    if (topKRegions.length > 0) {
                        const topKDiv = document.getElementById('topKRegions');
                        topKDiv.style.display = 'block';
                        topKDiv.innerHTML = `
                            <div class="font-semibold mb-1">Top Suspicious Regions:</div>
                            ${topKRegions.map(region => 
                                `<div class="text-xs">#${region.rank}: (${region.x}, ${region.y}) - ${region.percentage}% anomaly</div>`
                            ).join('')}
                        `;
                    }
                } else {
                    console.log('No TruFor visualization data available');
                }
            }
            
            // Hide loading, show results
            elements.loadingState.classList.add('hidden');
            elements.resultPanel.classList.remove('hidden');
        }
        
        // Display TruFor visualization
        function displayTruForVisualization(data) {
            console.log('Displaying TruFor visualization...');
            
            // Display original image
            if (data.original_image_url) {
                console.log('Setting original image URL');
                elements.originalImage.src = data.original_image_url;
                elements.originalImage.onload = function() {
                    console.log('Original image loaded');
                    
                    // Set canvas size to match image size
                    const imgWidth = elements.originalImage.naturalWidth;
                    const imgHeight = elements.originalImage.naturalHeight;
                    console.log('Image size:', imgWidth, 'x', imgHeight);
                    
                    // Calculate aspect ratio preserving dimensions with max size 300px
                    const maxSize = 300;
                    let displayWidth, displayHeight;
                    
                    if (imgWidth > imgHeight) {
                        // Landscape
                        displayWidth = maxSize;
                        displayHeight = Math.round(maxSize * (imgHeight / imgWidth));
                    } else {
                        // Portrait or square
                        displayHeight = maxSize;
                        displayWidth = Math.round(maxSize * (imgWidth / imgHeight));
                    }
                    
                    console.log('Canvas size set to:', displayWidth, 'x', displayHeight, '(aspect ratio preserved)');
                    
                    // Set canvas sizes with aspect ratio
                    elements.predictionOverlay.width = displayWidth;
                    elements.predictionOverlay.height = displayHeight;
                    elements.predictionOverlay.style.width = displayWidth + 'px';
                    elements.predictionOverlay.style.height = displayHeight + 'px';
                    
                    elements.predictionHeatmap.width = displayWidth;
                    elements.predictionHeatmap.height = displayHeight;
                    elements.predictionHeatmap.style.width = displayWidth + 'px';
                    elements.predictionHeatmap.style.height = displayHeight + 'px';
                    
                    // Draw heatmap after image is fully loaded
                    if (data.prediction_map) {
                        console.log('Drawing prediction heatmap...');
                        console.log('Prediction map data:', data.prediction_map.length, 'x', data.prediction_map[0].length);
                        
                        // Draw heatmap immediately after image loads
                        drawHeatmap(elements.predictionHeatmap, data.prediction_map, 'forgery');
                    } else {
                        console.log('No prediction map data available');
                    }
                    
                    // Draw confidence map if available
                    if (data.has_confidence_map && data.confidence_map && elements.confidenceMapSection) {
                        console.log('Drawing confidence map...');
                        elements.confidenceMapSection.classList.remove('hidden');
                        elements.confidenceMap.width = displayWidth;
                        elements.confidenceMap.height = displayHeight;
                        elements.confidenceMap.style.width = displayWidth + 'px';
                        elements.confidenceMap.style.height = displayHeight + 'px';
                        drawHeatmap(elements.confidenceMap, data.confidence_map, 'confidence');
                    }
                    
                    // Draw noiseprint if available
                    if (data.has_noiseprint && data.noiseprint_map && elements.noiseprintSection) {
                        console.log('Drawing noiseprint map...');
                        elements.noiseprintSection.classList.remove('hidden');
                        elements.noiseprintMap.width = displayWidth;
                        elements.noiseprintMap.height = displayHeight;
                        elements.noiseprintMap.style.width = displayWidth + 'px';
                        elements.noiseprintMap.style.height = displayHeight + 'px';
                        drawHeatmap(elements.noiseprintMap, data.noiseprint_map, 'noiseprint');
                    }
                };
            }
        }
        
        // Smooth colormap function - no black regions
        function smoothColormap(value) {
            // Clamp value to [0, 1]
            value = Math.max(0, Math.min(1, value));
            
            // Simple linear interpolation from blue to red
            // Blue (0,0,255) -> Cyan (0,255,255) -> Green (0,255,0) -> Yellow (255,255,0) -> Red (255,0,0)
            
            if (value < 0.25) {
                // Blue to Cyan: (0,0,255) to (0,255,255)
                const t = value * 4;
                return [0, t, 1];
            } else if (value < 0.5) {
                // Cyan to Green: (0,255,255) to (0,255,0)
                const t = (value - 0.25) * 4;
                return [0, 1, 1 - t];
            } else if (value < 0.75) {
                // Green to Yellow: (0,255,0) to (255,255,0)
                const t = (value - 0.5) * 4;
                return [t, 1, 0];
            } else {
                // Yellow to Red: (255,255,0) to (255,0,0)
                const t = (value - 0.75) * 4;
                return [1, 1 - t, 0];
            }
        }
        
        // Draw heatmap on canvas - UPDATED VERSION WITH SMOOTH COLORMAP
        function drawHeatmap(canvas, data, type) {
            console.log(`🎨 NEW VERSION: Drawing ${type} heatmap with SMOOTH COLORMAP...`);
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            console.log(`Canvas size: ${width}x${height}`);
            console.log(`Data size: ${data.length}x${data[0].length}`);
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Create image data
            const imageData = ctx.createImageData(width, height);
            const pixels = imageData.data;
            
            // Debug data range
            let minVal = Infinity;
            let maxVal = -Infinity;
            for (let y = 0; y < data.length; y++) {
                for (let x = 0; x < data[y].length; x++) {
                    const value = data[y][x];
                    if (value < minVal) minVal = value;
                    if (value > maxVal) maxVal = value;
                }
            }
            console.log(`${type} data range:`, minVal, 'to', maxVal);
            console.log(`🎨 USING SMOOTH COLORMAP for type: ${type}`);
            
            // Test smoothColormap function
            if (type === 'forgery') {
                console.log('🧪 Testing smoothColormap:');
                console.log('Value 0.0:', smoothColormap(0.0));
                console.log('Value 0.25:', smoothColormap(0.25));
                console.log('Value 0.5:', smoothColormap(0.5));
                console.log('Value 0.75:', smoothColormap(0.75));
                console.log('Value 1.0:', smoothColormap(1.0));
            }
            
            // Draw heatmap based on type
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dataX = Math.floor((x / width) * data[0].length);
                    const dataY = Math.floor((y / height) * data.length);
                    const pixelIndex = (y * width + x) * 4;
                    
                    if (dataY < data.length && dataX < data[dataY].length) {
                        const value = data[dataY][dataX];
                        
                        if (type === 'forgery') {
                            // Anomaly map: Smooth colormap (blue to red) - no black regions
                            const normalizedValue = Math.max(0, Math.min(1, value));
                            const [r, g, b] = smoothColormap(normalizedValue);
                            
                            // Debug: Check for black regions
                            if (r === 0 && g === 0 && b === 0) {
                                console.log(`Black pixel detected at (${x}, ${y}), value: ${value}, normalized: ${normalizedValue}`);
                            }
                            
                            pixels[pixelIndex] = Math.round(255 * r);     // Red
                            pixels[pixelIndex + 1] = Math.round(255 * g); // Green
                            pixels[pixelIndex + 2] = Math.round(255 * b); // Blue
                            pixels[pixelIndex + 3] = 255; // Alpha
                            
                        } else if (type === 'confidence') {
                            // Confidence map: grayscale with proper contrast enhancement
                            const normalizedValue = Math.max(0, Math.min(1, value));
                            // Map the actual data range [0.2, 1.0] to [0, 1] for better contrast
                            const enhancedValue = Math.max(0, Math.min(1, (normalizedValue - 0.2) / 0.8));
                            const intensity = Math.round(255 * enhancedValue);
                            
                            pixels[pixelIndex] = intensity;     // Red
                            pixels[pixelIndex + 1] = intensity; // Green
                            pixels[pixelIndex + 2] = intensity; // Blue
                            pixels[pixelIndex + 3] = 255;       // Alpha
                            
                        } else if (type === 'noiseprint') {
                            // Noiseprint++: grayscale
                            const normalizedValue = Math.max(0, Math.min(1, value));
                            const intensity = Math.round(255 * normalizedValue);
                            
                            pixels[pixelIndex] = intensity;     // Red
                            pixels[pixelIndex + 1] = intensity; // Green
                            pixels[pixelIndex + 2] = intensity; // Blue
                            pixels[pixelIndex + 3] = 255;       // Alpha
                        }
                    } else {
                        // Fill out-of-bounds pixels with black
                        pixels[pixelIndex] = 0;
                        pixels[pixelIndex + 1] = 0;
                        pixels[pixelIndex + 2] = 0;
                        pixels[pixelIndex + 3] = 255;
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            console.log(`✅ NEW VERSION: ${type} heatmap drawn successfully with SMOOTH COLORMAP!`);
        }
        
        // Reset upload
        function resetUpload() {
            console.log('Resetting upload...');
            elements.uploadCard.classList.remove('hidden');
            elements.loadingState.classList.add('hidden');
            elements.resultPanel.classList.add('hidden');
            elements.errorAlert.classList.add('hidden');
            elements.truforVisualization.classList.add('hidden');
            elements.detectionScoreStat.style.display = 'none';
            elements.fileInput.value = '';
        }
        
        // Global variables for hover functionality
        let currentImageData = null;
        let topKRegions = [];

        // Show decision details modal
        function showDecisionDetails() {
            if (!currentImageData) {
                alert('No image data available. Please analyze an image first.');
                return;
            }
            
            const modal = document.getElementById('decisionModal');
            const details = document.getElementById('decisionDetails');
            
            if (!modal || !details) {
                alert('Modal elements not found');
                return;
            }
            
            const integrity = currentImageData.integrity || 0;
            const fakeProb = 1 - integrity;
            let evidenceReliability = 0.5;
            
            if (currentImageData.confidence_map && Array.isArray(currentImageData.confidence_map) && currentImageData.confidence_map.length > 0) {
                const flatConfidence = currentImageData.confidence_map.flat();
                evidenceReliability = flatConfidence.reduce((sum, val) => sum + val, 0) / flatConfidence.length;
            }
            
            try {
                details.innerHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-gray-100 p-4 rounded">
                            <h4 class="font-bold text-sm mb-2">Decision Criteria</h4>
                            <p class="text-sm">Integrity: ${Math.round(integrity * 100)}%</p>
                            <p class="text-sm">Evidence Reliability: ${Math.round(evidenceReliability * 100)}%</p>
                            <p class="text-sm">Fake Likelihood: ${Math.round(fakeProb * 100)}%</p>
                        </div>
                        <div class="bg-gray-100 p-4 rounded">
                            <h4 class="font-bold text-sm mb-2">Decision Thresholds</h4>
                            <p class="text-sm">AUTHENTIC: ≥70% integrity + ≥40% reliability</p>
                            <p class="text-sm">LIKELY AUTHENTIC: 55-70% integrity</p>
                            <p class="text-sm">INCONCLUSIVE: 45-55% integrity</p>
                            <p class="text-sm">LIKELY FORGED: 30-45% integrity + ≥40% reliability</p>
                            <p class="text-sm">FORGED: <30% integrity + ≥50% reliability</p>
                        </div>
                    </div>
                    <div class="bg-gray-100 p-4 rounded">
                        <h4 class="font-bold text-sm mb-2">Analysis Summary</h4>
                        <p class="text-sm">This image shows ${Math.round(integrity * 100)}% integrity with ${Math.round(evidenceReliability * 100)}% evidence reliability. The confidence-weighted pooling mechanism has been applied to provide a more robust assessment.</p>
    </div>
                `;
                
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
            } catch (error) {
                console.error('❌ Error setting modal content:', error);
                alert('Error setting modal content: ' + error.message);
            }
        }

        // Close decision modal
        function closeDecisionModal() {
            const modal = document.getElementById('decisionModal');
            if (modal) {
                modal.classList.add('hidden');
                modal.style.display = 'none';
            }
        }

        // Show hover values on canvas
        function showHoverValues(event, type) {
            if (!currentImageData || !currentImageData.prediction_map) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            let value = 0;
            let confidence = 0;
            
            if (type === 'anomaly' && currentImageData.prediction_map && currentImageData.prediction_map.length > 0) {
                // Map mouse position to data array indices
                // Use canvas.width/height (the actual canvas size, not display size)
                const dataY = Math.floor((y / rect.height) * currentImageData.prediction_map.length);
                const dataX = Math.floor((x / rect.width) * currentImageData.prediction_map[0].length);
                
                // Bounds check with safety margins
                if (dataY >= 0 && dataY < currentImageData.prediction_map.length && 
                    dataX >= 0 && dataX < currentImageData.prediction_map[dataY].length) {
                    value = currentImageData.prediction_map[dataY][dataX];
                }
                
                if (currentImageData.confidence_map && currentImageData.confidence_map.length > 0) {
                    const confY = Math.floor((y / rect.height) * currentImageData.confidence_map.length);
                    const confX = Math.floor((x / rect.width) * currentImageData.confidence_map[0].length);
                    
                    if (confY >= 0 && confY < currentImageData.confidence_map.length && 
                        confX >= 0 && confX < currentImageData.confidence_map[confY].length) {
                        confidence = currentImageData.confidence_map[confY][confX];
                    }
                }
            }
            
            const tooltip = document.getElementById('hoverTooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top + 10) + 'px';
            tooltip.innerHTML = `
                <div>Anomaly: ${(value * 100).toFixed(1)}%</div>
                <div>Confidence: ${(confidence * 100).toFixed(1)}%</div>
                <div>Weighted: ${((value * confidence) * 100).toFixed(1)}%</div>
            `;
        }

        // Hide hover values
        function hideHoverValues() {
            document.getElementById('hoverTooltip').style.display = 'none';
        }

        // Find and display top-K regions
        function findTopKRegions(data, k = 3) {
            if (!data || !Array.isArray(data) || data.length === 0 || !data[0] || !Array.isArray(data[0])) {
                console.log('Invalid data for findTopKRegions:', data);
                return [];
            }
            
            const flatData = data.flat();
            const indexedData = flatData.map((value, index) => ({
                value,
                index,
                x: index % data[0].length,
                y: Math.floor(index / data[0].length)
            }));
            
            // Sort by value descending and take top K
            return indexedData
                .sort((a, b) => b.value - a.value)
                .slice(0, k)
                .map((item, i) => ({
                    rank: i + 1,
                    value: item.value,
                    x: item.x,
                    y: item.y,
                    percentage: (item.value * 100).toFixed(1)
                }));
        }

        
        // Update progress bar
        function updateProgress(percentage, text) {
            const progressBar = document.getElementById('progressBar');
            const loadingText = document.getElementById('loadingText');
            
            if (progressBar) {
                progressBar.style.width = `${percentage}%`;
            }
            if (loadingText) {
                loadingText.textContent = text;
            }
        }

        // Keyboard shortcuts
        function handleKeyboardShortcuts(event) {
            if (event.key === 'Escape') {
                closeDecisionModal();
            } else if (event.key === 'Enter' && event.ctrlKey) {
                // Ctrl+Enter to trigger file input
                elements.fileInput.click();
            } else if (event.key === 'r' && event.ctrlKey) {
                // Ctrl+R to reset
                event.preventDefault();
                resetUpload();
            }
        }

        // Initialize event listeners only once
        function initializeEventListeners() {
            
            // Add keyboard event listener
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // Drag and drop functionality
            elements.uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadZone.classList.add('border-primary', 'bg-primary/10');
            });
            
            elements.uploadZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                elements.uploadZone.classList.remove('border-primary', 'bg-primary/10');
            });
            
            elements.uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.uploadZone.classList.remove('border-primary', 'bg-primary/10');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    elements.fileInput.files = files;
                    elements.fileInput.dispatchEvent(new Event('change'));
                }
            });
            
            // File selection event
            if (elements.fileInput) {
                // Remove all existing listeners
                const newFileInput = elements.fileInput.cloneNode(true);
                elements.fileInput.parentNode.replaceChild(newFileInput, elements.fileInput);
                elements.fileInput = newFileInput;
                
                elements.fileInput.addEventListener('change', function(e) {
                    console.log('File input changed');
                    const files = e.target.files;
                    if (files.length > 0) {
                        console.log('Processing file:', files[0].name);
                        handleFile(files[0]);
                    }
                });
            } else {
                console.error('fileInput element not found!');
            }
            
            // Click to select file - only if not already processing
            if (elements.uploadZone) {
                // Remove all existing listeners
                const newUploadZone = elements.uploadZone.cloneNode(true);
                elements.uploadZone.parentNode.replaceChild(newUploadZone, elements.uploadZone);
                elements.uploadZone = newUploadZone;
                
                elements.uploadZone.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Only open file dialog if not already processing
                    if (!elements.uploadCard.classList.contains('hidden')) {
                        console.log('Upload zone clicked');
                        elements.fileInput.click();
                    } else {
                        console.log('Upload zone clicked but already processing, ignoring');
                    }
                });
            }
            
            // Decision stat click event
            if (elements.decisionStat) {
                // Remove all existing listeners
                const newDecisionStat = elements.decisionStat.cloneNode(true);
                elements.decisionStat.parentNode.replaceChild(newDecisionStat, elements.decisionStat);
                elements.decisionStat = newDecisionStat;
                
                // Add click event listener
                elements.decisionStat.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showDecisionDetails();
                });
                
                console.log('✅ Decision stat event listeners added successfully');
            } else {
                console.error('❌ decisionStat element not found!');
            }
            
        }
        
        // Initialize event listeners
        initializeEventListeners();
        
        // Add anomaly map toggle button event listeners
        if (elements.btnRawAnomaly && elements.btnWeightedAnomaly) {
            elements.btnRawAnomaly.addEventListener('click', function() {
                console.log('🔵 Switching to RAW anomaly map');
                // Update button styles
                elements.btnRawAnomaly.style.background = '#3b82f6';
                elements.btnRawAnomaly.style.color = 'white';
                elements.btnWeightedAnomaly.style.background = 'white';
                elements.btnWeightedAnomaly.style.color = '#6b7280';
                
                // Redraw with raw prediction map
                if (window.currentImageData && window.currentImageData.prediction_map) {
                    console.log('Drawing raw prediction_map, size:', 
                        window.currentImageData.prediction_map.length, 'x', 
                        window.currentImageData.prediction_map[0].length);
                    drawHeatmap(elements.predictionHeatmap, window.currentImageData.prediction_map, 'forgery');
                } else {
                    console.error('No prediction_map available!');
                }
            });
            
            elements.btnWeightedAnomaly.addEventListener('click', function() {
                console.log('🟢 Switching to WEIGHTED anomaly map');
                // Update button styles
                elements.btnWeightedAnomaly.style.background = '#3b82f6';
                elements.btnWeightedAnomaly.style.color = 'white';
                elements.btnRawAnomaly.style.background = 'white';
                elements.btnRawAnomaly.style.color = '#6b7280';
                
                // Debug: Check what data is available
                console.log('Available data keys:', Object.keys(window.currentImageData || {}));
                console.log('Has weighted_prediction_map?', !!window.currentImageData?.weighted_prediction_map);
                
                // Redraw with weighted prediction map
                if (window.currentImageData && window.currentImageData.weighted_prediction_map) {
                    console.log('Drawing weighted_prediction_map, size:', 
                        window.currentImageData.weighted_prediction_map.length, 'x', 
                        window.currentImageData.weighted_prediction_map[0].length);
                    console.log('Sample values - Raw:', window.currentImageData.prediction_map[100][100], 
                        'Weighted:', window.currentImageData.weighted_prediction_map[100][100]);
                    drawHeatmap(elements.predictionHeatmap, window.currentImageData.weighted_prediction_map, 'forgery');
                } else {
                    console.error('No weighted_prediction_map available!');
                }
            });
            
            console.log('✅ Anomaly map toggle buttons initialized');
        }
        
        // Ensure modal is hidden on page load
        const modal = document.getElementById('decisionModal');
        if (modal) {
            modal.classList.add('hidden');
            modal.style.display = 'none';
        }
        
    </script>
    
    <!-- JavaScript functions are now inline in this file -->
</body>
</html>
